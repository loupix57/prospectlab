"""
Module de gestion des analyses Pentest
Contient toutes les méthodes liées aux analyses Pentest
"""

import json
from urllib.parse import urlparse
from .base import DatabaseBase


class PentestManager(DatabaseBase):
    """
    Gère toutes les opérations sur les analyses Pentest
    """
    
    def __init__(self, *args, **kwargs):
        """Initialise le module pentest"""
        super().__init__(*args, **kwargs)
    
    def save_pentest_analysis(self, entreprise_id, url, pentest_data):
        """
        Sauvegarde une analyse Pentest avec normalisation des données
        
        Args:
            entreprise_id: ID de l'entreprise
            url: URL analysée
            pentest_data: Dictionnaire avec les données pentest
        
        Returns:
            int: ID de l'analyse créée
        """
        conn = self.get_connection()
        cursor = conn.cursor()
        
        parsed = urlparse(url)
        domain = parsed.netloc or parsed.path.split('/')[0]
        domain_clean = domain.replace('www.', '') if domain else ''
        
        # Sauvegarder l'analyse principale
        cursor.execute('''
            INSERT INTO analyses_pentest (
                entreprise_id, url, domain, sql_injection, xss_vulnerabilities,
                csrf_vulnerabilities, authentication_issues, authorization_issues,
                sensitive_data_exposure, ssl_tls_analysis,
                waf_detection, api_security, network_scan,
                pentest_details, risk_score
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            entreprise_id,
            url,
            domain_clean,
            json.dumps(pentest_data.get('sql_injection', {})) if pentest_data.get('sql_injection') else None,
            json.dumps(pentest_data.get('xss_vulnerabilities', [])) if pentest_data.get('xss_vulnerabilities') else None,
            json.dumps(pentest_data.get('csrf_vulnerabilities', [])) if pentest_data.get('csrf_vulnerabilities') else None,
            json.dumps(pentest_data.get('authentication_issues', [])) if pentest_data.get('authentication_issues') else None,
            json.dumps(pentest_data.get('authorization_issues', [])) if pentest_data.get('authorization_issues') else None,
            json.dumps(pentest_data.get('sensitive_data_exposure', [])) if pentest_data.get('sensitive_data_exposure') else None,
            json.dumps(pentest_data.get('ssl_tls', {})) if pentest_data.get('ssl_tls') else None,
            json.dumps(pentest_data.get('waf_detection', {})) if pentest_data.get('waf_detection') else None,
            json.dumps(pentest_data.get('api_security', {})) if pentest_data.get('api_security') else None,
            json.dumps(pentest_data.get('network_scan', {})) if pentest_data.get('network_scan') else None,
            json.dumps(pentest_data) if pentest_data else None,
            pentest_data.get('risk_score', 0)
        ))
        
        analysis_id = cursor.lastrowid
        
        # Sauvegarder les vulnérabilités dans la table normalisée
        vulnerabilities = pentest_data.get('vulnerabilities', [])
        if vulnerabilities:
            if isinstance(vulnerabilities, str):
                try:
                    vulnerabilities = json.loads(vulnerabilities)
                except:
                    vulnerabilities = []
            if isinstance(vulnerabilities, list):
                for vuln in vulnerabilities:
                    if isinstance(vuln, dict):
                        name = vuln.get('name') or vuln.get('title') or str(vuln)
                        severity = vuln.get('severity') or vuln.get('level')
                        description = vuln.get('description')
                        recommendation = vuln.get('recommendation') or vuln.get('fix')
                    else:
                        name = str(vuln)
                        severity = None
                        description = None
                        recommendation = None
                    if name:
                        cursor.execute('''
                            INSERT INTO analysis_pentest_vulnerabilities (analysis_id, name, severity, description, recommendation)
                            VALUES (?, ?, ?, ?, ?)
                        ''', (analysis_id, name, severity, description, recommendation))
        
        # Sauvegarder les headers de sécurité dans la table normalisée
        security_headers = pentest_data.get('security_headers', {})
        if security_headers:
            if isinstance(security_headers, str):
                try:
                    security_headers = json.loads(security_headers)
                except:
                    security_headers = {}
            if isinstance(security_headers, dict):
                for header_name, header_data in security_headers.items():
                    if isinstance(header_data, dict):
                        status = header_data.get('status') or header_data.get('present')
                    else:
                        status = 'present' if header_data else 'missing'
                    cursor.execute('''
                        INSERT OR REPLACE INTO analysis_pentest_security_headers (analysis_id, header_name, status)
                        VALUES (?, ?, ?)
                    ''', (analysis_id, header_name, status))
        
        # Sauvegarder les vulnérabilités CMS dans la table normalisée
        cms_vulnerabilities = pentest_data.get('cms_vulnerabilities', {})
        if cms_vulnerabilities:
            if isinstance(cms_vulnerabilities, str):
                try:
                    cms_vulnerabilities = json.loads(cms_vulnerabilities)
                except:
                    cms_vulnerabilities = {}
            if isinstance(cms_vulnerabilities, dict):
                for vuln_name, vuln_data in cms_vulnerabilities.items():
                    if isinstance(vuln_data, dict):
                        severity = vuln_data.get('severity') or vuln_data.get('level')
                        description = vuln_data.get('description')
                    else:
                        severity = None
                        description = str(vuln_data) if vuln_data else None
                    cursor.execute('''
                        INSERT INTO analysis_pentest_cms_vulnerabilities (analysis_id, name, severity, description)
                        VALUES (?, ?, ?, ?)
                    ''', (analysis_id, vuln_name, severity, description))
        
        # Sauvegarder les ports ouverts dans la table normalisée
        network_scan = pentest_data.get('network_scan', {})
        if network_scan:
            if isinstance(network_scan, str):
                try:
                    network_scan = json.loads(network_scan)
                except:
                    network_scan = {}
            if isinstance(network_scan, dict):
                open_ports = network_scan.get('open_ports', [])
                if not open_ports and network_scan.get('ports'):
                    open_ports = network_scan.get('ports', [])
                if isinstance(open_ports, list):
                    for port_data in open_ports:
                        if isinstance(port_data, dict):
                            port = port_data.get('port') or port_data.get('number')
                            service = port_data.get('service') or port_data.get('name')
                        else:
                            port = int(port_data) if isinstance(port_data, (int, str)) and str(port_data).isdigit() else None
                            service = None
                        if port:
                            cursor.execute('''
                                INSERT OR IGNORE INTO analysis_pentest_open_ports (analysis_id, port, service)
                                VALUES (?, ?, ?)
                            ''', (analysis_id, port, service))
        
        conn.commit()
        conn.close()
        
        return analysis_id
    
    def _load_pentest_analysis_normalized_data(self, cursor, analysis_id):
        """
        Charge les données normalisées d'une analyse Pentest
        
        Args:
            cursor: Curseur SQLite
            analysis_id: ID de l'analyse
        
        Returns:
            dict: Dictionnaire avec toutes les données normalisées
        """
        # Charger les vulnérabilités
        cursor.execute('''
            SELECT name, severity, description, recommendation 
            FROM analysis_pentest_vulnerabilities 
            WHERE analysis_id = ?
        ''', (analysis_id,))
        vulnerabilities = []
        for row in cursor.fetchall():
            vuln = {'name': row['name']}
            if row['severity']:
                vuln['severity'] = row['severity']
            if row['description']:
                vuln['description'] = row['description']
            if row['recommendation']:
                vuln['recommendation'] = row['recommendation']
            vulnerabilities.append(vuln)
        
        # Charger les headers de sécurité
        cursor.execute('SELECT header_name, status FROM analysis_pentest_security_headers WHERE analysis_id = ?', (analysis_id,))
        security_headers = {}
        for row in cursor.fetchall():
            security_headers[row['header_name']] = {'status': row['status']}
        
        # Charger les vulnérabilités CMS
        cursor.execute('''
            SELECT name, severity, description 
            FROM analysis_pentest_cms_vulnerabilities 
            WHERE analysis_id = ?
        ''', (analysis_id,))
        cms_vulnerabilities = {}
        for row in cursor.fetchall():
            cms_vulnerabilities[row['name']] = {
                'severity': row['severity'],
                'description': row['description']
            }
        
        # Charger les ports ouverts
        cursor.execute('SELECT port, service FROM analysis_pentest_open_ports WHERE analysis_id = ?', (analysis_id,))
        open_ports = []
        for row in cursor.fetchall():
            port_data = {'port': row['port']}
            if row['service']:
                port_data['service'] = row['service']
            open_ports.append(port_data)
        
        return {
            'vulnerabilities': vulnerabilities,
            'security_headers': security_headers,
            'security_headers_analysis': security_headers,  # Compatibilité
            'cms_vulnerabilities': cms_vulnerabilities,
            'open_ports': open_ports
        }
    
    def get_pentest_analysis_by_entreprise(self, entreprise_id):
        """
        Récupère l'analyse Pentest d'une entreprise avec données normalisées
        
        Args:
            entreprise_id: ID de l'entreprise
        
        Returns:
            dict: Analyse Pentest ou None
        """
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM analyses_pentest
            WHERE entreprise_id = ?
            ORDER BY date_analyse DESC
            LIMIT 1
        ''', (entreprise_id,))
        
        row = cursor.fetchone()
        
        if row:
            analysis = dict(row)
            analysis_id = analysis['id']
            
            # Charger les données normalisées
            normalized = self._load_pentest_analysis_normalized_data(cursor, analysis_id)
            analysis.update(normalized)
            
            # Ajouter les ports ouverts au network_scan si présent
            if 'network_scan' in analysis and analysis['network_scan']:
                try:
                    network_scan = json.loads(analysis['network_scan']) if isinstance(analysis['network_scan'], str) else analysis['network_scan']
                    if isinstance(network_scan, dict):
                        network_scan['open_ports'] = normalized['open_ports']
                        analysis['network_scan'] = network_scan
                except:
                    pass
            
            # Parser les autres champs JSON
            json_fields = ['sql_injection', 'xss_vulnerabilities', 'csrf_vulnerabilities',
                          'authentication_issues', 'authorization_issues', 'sensitive_data_exposure',
                          'ssl_tls_analysis', 'waf_detection', 'api_security', 'pentest_details']
            for field in json_fields:
                if analysis.get(field):
                    try:
                        analysis[field] = json.loads(analysis[field])
                    except:
                        pass
            
            conn.close()
            return analysis
        
        conn.close()
        return None
    
    def update_pentest_analysis(self, analysis_id, pentest_data):
        """
        Met à jour une analyse Pentest existante
        
        Args:
            analysis_id: ID de l'analyse
            pentest_data: Nouvelles données pentest
        
        Returns:
            int: ID de l'analyse (nouvelle)
        """
        # Supprimer l'ancienne analyse et en créer une nouvelle
        conn = self.get_connection()
        cursor = conn.cursor()
        
        # Récupérer l'entreprise_id et l'URL de l'analyse existante
        cursor.execute('SELECT entreprise_id, url FROM analyses_pentest WHERE id = ?', (analysis_id,))
        row = cursor.fetchone()
        if not row:
            conn.close()
            return None
        
        entreprise_id = row[0]
        url = row[1]
        
        # Supprimer l'ancienne analyse (les CASCADE supprimeront les données normalisées)
        cursor.execute('DELETE FROM analyses_pentest WHERE id = ?', (analysis_id,))
        
        conn.commit()
        conn.close()
        
        # Créer une nouvelle analyse avec les mêmes données
        return self.save_pentest_analysis(entreprise_id, url, pentest_data)
    
    def get_pentest_analysis_by_url(self, url):
        """
        Récupère une analyse Pentest par son URL avec données normalisées
        
        Args:
            url: URL analysée
        
        Returns:
            dict: Analyse Pentest ou None
        """
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT ap.*, e.nom as entreprise_nom, e.id as entreprise_id
            FROM analyses_pentest ap
            LEFT JOIN entreprises e ON ap.entreprise_id = e.id
            WHERE ap.url = ?
            ORDER BY ap.date_analyse DESC
            LIMIT 1
        ''', (url,))
        
        row = cursor.fetchone()
        
        if row:
            analysis = dict(row)
            analysis_id = analysis['id']
            
            # Charger les données normalisées
            normalized = self._load_pentest_analysis_normalized_data(cursor, analysis_id)
            analysis.update(normalized)
            
            # Ajouter les ports ouverts au network_scan si présent
            if 'network_scan' in analysis and analysis['network_scan']:
                try:
                    network_scan = json.loads(analysis['network_scan']) if isinstance(analysis['network_scan'], str) else analysis['network_scan']
                    if isinstance(network_scan, dict):
                        network_scan['open_ports'] = normalized['open_ports']
                        analysis['network_scan'] = network_scan
                except:
                    pass
            
            # Parser les autres champs JSON
            json_fields = ['sql_injection', 'xss_vulnerabilities', 'csrf_vulnerabilities',
                         'authentication_issues', 'authorization_issues', 'sensitive_data_exposure',
                          'ssl_tls_analysis', 'waf_detection', 'api_security', 'pentest_details']
            for field in json_fields:
                if analysis.get(field):
                    try:
                        analysis[field] = json.loads(analysis[field])
                    except:
                        pass
            
            conn.close()
            return analysis
        
        conn.close()
        return None
    
    def get_pentest_analysis(self, analysis_id):
        """
        Récupère une analyse Pentest par ID avec données normalisées
        
        Args:
            analysis_id: ID de l'analyse
        
        Returns:
            dict: Analyse Pentest ou None
        """
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT ap.*, e.nom as entreprise_nom, e.id as entreprise_id
            FROM analyses_pentest ap
            LEFT JOIN entreprises e ON ap.entreprise_id = e.id
            WHERE ap.id = ?
        ''', (analysis_id,))
        
        row = cursor.fetchone()
        
        if row:
            analysis = dict(row)
            
            # Charger les données normalisées
            normalized = self._load_pentest_analysis_normalized_data(cursor, analysis_id)
            analysis.update(normalized)
            
            # Ajouter les ports ouverts au network_scan si présent
            if 'network_scan' in analysis and analysis['network_scan']:
                try:
                    network_scan = json.loads(analysis['network_scan']) if isinstance(analysis['network_scan'], str) else analysis['network_scan']
                    if isinstance(network_scan, dict):
                        network_scan['open_ports'] = normalized['open_ports']
                        analysis['network_scan'] = network_scan
                except:
                    pass
            
            # Parser les autres champs JSON
            json_fields = ['sql_injection', 'xss_vulnerabilities', 'csrf_vulnerabilities',
                          'authentication_issues', 'authorization_issues', 'sensitive_data_exposure',
                          'ssl_tls_analysis', 'waf_detection', 'api_security', 'pentest_details']
            for field in json_fields:
                if analysis.get(field):
                    try:
                        analysis[field] = json.loads(analysis[field])
                    except:
                        pass
            
            conn.close()
            return analysis
        
        conn.close()
        return None
    
    def get_all_pentest_analyses(self):
        """
        Récupère toutes les analyses Pentest avec données normalisées
        
        Returns:
            list: Liste des analyses Pentest
        """
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT ap.*, e.nom as entreprise_nom
            FROM analyses_pentest ap
            LEFT JOIN entreprises e ON ap.entreprise_id = e.id
            ORDER BY ap.date_analyse DESC
        ''')
        
        rows = cursor.fetchall()
        
        analyses = []
        for row in rows:
            analysis = dict(row)
            analysis_id = analysis['id']
            
            # Charger les données normalisées
            normalized = self._load_pentest_analysis_normalized_data(cursor, analysis_id)
            analysis.update(normalized)
            
            # Ajouter le compteur pour compatibilité
            analysis['vulnerabilities_count'] = len(analysis.get('vulnerabilities', []))
            
            analyses.append(analysis)
        
        conn.close()
        return analyses
    
    def delete_pentest_analysis(self, analysis_id):
        """
        Supprime une analyse Pentest
        
        Args:
            analysis_id: ID de l'analyse à supprimer
        
        Returns:
            bool: True si supprimée, False sinon
        """
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute('DELETE FROM analyses_pentest WHERE id = ?', (analysis_id,))
        deleted = cursor.rowcount > 0
        
        conn.commit()
        conn.close()
        return deleted
