"""
Service d'analyse de sécurité (Pentest)
Détection de vulnérabilités et failles de sécurité
"""

import subprocess
import shutil
import json
import re
import os
from urllib.parse import urlparse
from typing import Dict, List, Optional
import requests
from bs4 import BeautifulSoup

# Importer la configuration
try:
    from config import WSL_DISTRO, WSL_USER, PENTEST_TOOL_TIMEOUT
except ImportError:
    # Valeurs par défaut si config n'est pas disponible
    WSL_DISTRO = os.environ.get('WSL_DISTRO', 'kali-linux')
    WSL_USER = os.environ.get('WSL_USER', 'loupix')
    PENTEST_TOOL_TIMEOUT = int(os.environ.get('PENTEST_TOOL_TIMEOUT', '120'))


class PentestAnalyzer:
    """
    Analyseur de sécurité pour détecter les vulnérabilités
    ⚠️ À utiliser uniquement avec autorisation écrite
    """
    
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        self._check_tools_availability()
    
    def _check_tools_availability(self):
        """Vérifie la disponibilité des outils de pentest"""
        self.wsl_available = shutil.which('wsl') is not None
        # Utiliser les variables d'environnement pour WSL
        self.wsl_cmd_base = ['wsl', '-d', WSL_DISTRO, '-u', WSL_USER] if self.wsl_available else None
        
        # Vérifier les outils disponibles
        self.tools = {
            'sqlmap': self._check_tool('sqlmap'),
            'wpscan': self._check_tool('wpscan'),
            'nikto': self._check_tool('nikto'),
            'wapiti': self._check_tool('wapiti'),
            'nmap': self._check_tool('nmap'),
            'sslscan': self._check_tool('sslscan'),
            'masscan': self._check_tool('masscan'),
            'ffuf': self._check_tool('ffuf'),
            'gobuster': self._check_tool('gobuster'),
            'dirsearch': self._check_tool('dirsearch'),
        }
    
    def _check_tool(self, tool_name: str) -> bool:
        """Vérifie si un outil est disponible"""
        if shutil.which(tool_name):
            return True
        if self.wsl_available:
            # Essayer d'abord avec l'utilisateur configuré
            try:
                result = subprocess.run(
                    self.wsl_cmd_base + ['which', tool_name],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode == 0:
                    return True
            except:
                pass
            
            # Si ça échoue, essayer sans utilisateur
            try:
                result = subprocess.run(
                    ['wsl', '-d', WSL_DISTRO, 'which', tool_name],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode == 0:
                    return True
            except:
                pass
        return False
    
    def _run_wsl_command(self, command: List[str], timeout: int = None) -> Dict:
        """
        Exécute une commande via WSL
        Optimisé pour réduire la surcharge de démarrage WSL
        Gère les cas où l'utilisateur spécifié ne fonctionne pas
        """
        if not self.wsl_available:
            return {'error': 'WSL non disponible'}
        
        # Utiliser le timeout depuis la config si non spécifié
        if timeout is None:
            timeout = PENTEST_TOOL_TIMEOUT
        
        # Essayer d'abord avec l'utilisateur configuré
        try:
            cmd = self.wsl_cmd_base + command
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='ignore',
                timeout=timeout,
                start_new_session=False
            )
            return {
                'success': result.returncode == 0,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'returncode': result.returncode
            }
        except subprocess.TimeoutExpired:
            return {'error': 'Timeout'}
        except Exception as e:
            # Si ça échoue avec l'utilisateur, essayer sans
            try:
                cmd = ['wsl', '-d', WSL_DISTRO] + command
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    encoding='utf-8',
                    errors='ignore',
                    timeout=timeout,
                    start_new_session=False
                )
                return {
                    'success': result.returncode == 0,
                    'stdout': result.stdout,
                    'stderr': result.stderr,
                    'returncode': result.returncode
                }
            except subprocess.TimeoutExpired:
                return {'error': 'Timeout'}
            except Exception as e2:
                return {'error': str(e2)}
    
    def scan_sql_injection(self, url: str) -> Dict:
        """Scan SQL injection avec SQLMap (mode passif)"""
        vulnerabilities = []
        
        if not self.tools['sqlmap']:
            return {'error': 'sqlmap non disponible', 'vulnerabilities': []}
        
        # Test rapide en mode passif (sans exploitation)
        result = self._run_wsl_command([
            'sqlmap',
            '-u', url,
            '--batch',
            '--crawl=2',
            '--level=1',
            '--risk=1',
            '--forms',
            '--threads=5'
        ], timeout=120)
        
        if result.get('success'):
            output = result['stdout']
            if 'injection' in output.lower() or 'vulnerable' in output.lower():
                vulnerabilities.append({
                    'type': 'SQL Injection',
                    'severity': 'High',
                    'description': 'Possible injection SQL détectée',
                    'details': output[:500]
                })
        
        return {
            'vulnerabilities': vulnerabilities,
            'scan_completed': result.get('success', False)
        }
    
    def scan_wordpress(self, url: str) -> Dict:
        """Scan WordPress avec WPScan"""
        vulnerabilities = []
        info = {}
        
        if not self.tools['wpscan']:
            return {'error': 'wpscan non disponible', 'vulnerabilities': []}
        
        # Scan WordPress (sans force brute par défaut)
        result = self._run_wsl_command([
            'wpscan',
            '--url', url,
            '--no-update',
            '--format', 'json'
        ], timeout=180)
        
        if result.get('success'):
            try:
                data = json.loads(result['stdout'])
                if 'version' in data:
                    info['version'] = data['version']
                if 'vulnerabilities' in data:
                    for vuln in data['vulnerabilities']:
                        vulnerabilities.append({
                            'type': 'WordPress Vulnerability',
                            'severity': vuln.get('severity', 'Medium'),
                            'title': vuln.get('title', ''),
                            'description': vuln.get('description', '')
                        })
            except:
                # Si JSON invalide, parser le texte
                if 'vulnerable' in result['stdout'].lower():
                    vulnerabilities.append({
                        'type': 'WordPress Vulnerability',
                        'severity': 'Medium',
                        'description': 'Vulnérabilités WordPress détectées'
                    })
        
        return {
            'vulnerabilities': vulnerabilities,
            'info': info,
            'scan_completed': result.get('success', False)
        }
    
    def scan_nikto(self, url: str) -> Dict:
        """Scan de vulnérabilités web avec Nikto"""
        vulnerabilities = []
        
        if not self.tools['nikto']:
            return {'error': 'nikto non disponible', 'vulnerabilities': []}
        
        result = self._run_wsl_command([
            'nikto',
            '-h', url,
            '-Format', 'txt'
        ], timeout=300)
        
        if result.get('success'):
            output = result['stdout']
            # Parser les résultats Nikto
            for line in output.split('\n'):
                if '+ ' in line and ('OSVDB' in line or 'found' in line.lower()):
                    vuln_match = re.search(r'\+ (.+)', line)
                    if vuln_match:
                        vulnerabilities.append({
                            'type': 'Web Vulnerability',
                            'severity': 'Medium',
                            'description': vuln_match.group(1)
                        })
        
        return {
            'vulnerabilities': vulnerabilities[:20],  # Limiter à 20
            'scan_completed': result.get('success', False)
        }

    def scan_ffuf_directories(self, url: str) -> Dict:
        """Bruteforce répertoires avec ffuf (rapide, wordlist dirb petite)"""
        if not self.tools.get('ffuf'):
            return {'error': 'ffuf non disponible', 'vulnerabilities': []}

        # Utilise la wordlist commune de Kali (petite)
        wordlist = '/usr/share/dirb/wordlists/common.txt'
        result = self._run_wsl_command([
            'ffuf',
            '-u', f'{url.rstrip("/")}/FUZZ',
            '-w', wordlist,
            '-mc', '200,301,302,307,401,403',
            '-of', 'json'
        ], timeout=90)

        vulns = []
        if result.get('success'):
            try:
                data = json.loads(result.get('stdout') or '{}')
                for entry in data.get('results', [])[:50]:
                    vulns.append({
                        'type': 'Directory/Resource',
                        'severity': 'Low',
                        'description': f"Ressource trouvée: {entry.get('url')}"
                    })
            except Exception as e:
                return {'error': f'Parse ffuf: {e}', 'vulnerabilities': []}

        return {
            'vulnerabilities': vulns,
            'scan_completed': result.get('success', False)
        }

    def scan_gobuster_directories(self, url: str) -> Dict:
        """Bruteforce répertoires avec gobuster (alternative à ffuf)"""
        if not self.tools.get('gobuster'):
            return {'error': 'gobuster non disponible', 'vulnerabilities': []}

        wordlist = '/usr/share/dirb/wordlists/common.txt'
        result = self._run_wsl_command([
            'gobuster',
            'dir',
            '-u', url,
            '-w', wordlist,
            '-q',  # Quiet mode
            '--no-error',
            '--status-codes', '200,301,302,307,401,403'
        ], timeout=90)

        vulns = []
        if result.get('success'):
            for line in result.get('stdout', '').split('\n'):
                if line.strip() and not line.startswith('='):
                    # Format: /path (Status: 200) [Size: 1234]
                    match = re.search(r'^(\S+)\s+\(Status:\s+\d+\)', line)
                    if match:
                        path = match.group(1)
                        vulns.append({
                            'type': 'Directory/Resource',
                            'severity': 'Low',
                            'description': f"Ressource trouvée: {url.rstrip('/')}{path}"
                        })

        return {
            'vulnerabilities': vulns[:50],  # Limiter à 50
            'scan_completed': result.get('success', False)
        }

    def scan_dirsearch_directories(self, url: str) -> Dict:
        """Bruteforce répertoires avec dirsearch (alternative à ffuf/gobuster)"""
        if not self.tools.get('dirsearch'):
            return {'error': 'dirsearch non disponible', 'vulnerabilities': []}

        result = self._run_wsl_command([
            'dirsearch',
            '-u', url,
            '-e', 'php,html,js,txt',
            '--quiet',
            '--json-report', '/tmp/dirsearch_report.json'
        ], timeout=90)

        vulns = []
        if result.get('success'):
            # Essayer de lire le rapport JSON
            try:
                json_result = self._run_wsl_command(['cat', '/tmp/dirsearch_report.json'], timeout=5)
                if json_result.get('success'):
                    data = json.loads(json_result.get('stdout', '{}'))
                    for path, info in data.items():
                        vulns.append({
                            'type': 'Directory/Resource',
                            'severity': 'Low',
                            'description': f"Ressource trouvée: {url.rstrip('/')}{path} (Status: {info.get('status', 'N/A')})"
                        })
            except:
                # Si pas de JSON, parser la sortie texte
                for line in result.get('stdout', '').split('\n'):
                    if '200' in line or '301' in line or '302' in line:
                        match = re.search(r'(\S+)\s+\(CODE:\d+\)', line)
                        if match:
                            path = match.group(1)
                            vulns.append({
                                'type': 'Directory/Resource',
                                'severity': 'Low',
                                'description': f"Ressource trouvée: {url.rstrip('/')}{path}"
                            })

        return {
            'vulnerabilities': vulns[:50],  # Limiter à 50
            'scan_completed': result.get('success', False)
        }

    def test_form_security(self, form: Dict, base_url: str) -> Dict:
        """
        Teste la sécurité d'un formulaire (SQL injection, XSS, CSRF)
        
        Args:
            form: Dictionnaire avec les infos du formulaire (action, method, fields, etc.)
            base_url: URL de base pour construire les URLs absolues
        
        Returns:
            Dict avec les résultats des tests de sécurité
        """
        from urllib.parse import urljoin, urlparse
        
        action_raw = form.get('action') or form.get('action_url', '')
        method = (form.get('method') or 'GET').upper()
        fields = form.get('fields', [])
        
        # Construire l'URL absolue
        if not action_raw or action_raw == '#' or action_raw.startswith('#'):
            return {'error': 'Action vide ou invalide', 'vulnerabilities': []}
        
        try:
            parsed_action = urlparse(action_raw)
            if parsed_action.scheme and parsed_action.netloc:
                action_url = action_raw
            else:
                action_url = urljoin(base_url, action_raw)
        except:
            return {'error': 'URL invalide', 'vulnerabilities': []}
        
        vulnerabilities = []
        security_issues = {
            'sql_injection': False,
            'xss': False,
            'csrf_missing': False,
            'password_plaintext': False,
            'file_upload_unsafe': False
        }
        
        # Test 1: Vérifier la protection CSRF
        has_csrf = form.get('has_csrf', False)
        if not has_csrf and method == 'POST':
            security_issues['csrf_missing'] = True
            vulnerabilities.append({
                'type': 'CSRF Protection Missing',
                'severity': 'Medium',
                'description': f'Formulaire POST sans protection CSRF détectée: {action_url}',
                'recommendation': 'Ajouter un token CSRF dans le formulaire'
            })
        
        # Test 2: Vérifier si les mots de passe sont en clair (pas de HTTPS)
        has_password = form.get('has_password', False)
        if has_password:
            if not action_url.startswith('https://'):
                security_issues['password_plaintext'] = True
                vulnerabilities.append({
                    'type': 'Password Transmission Over HTTP',
                    'severity': 'High',
                    'description': f'Formulaire avec mot de passe accessible via HTTP: {action_url}',
                    'recommendation': 'Forcer HTTPS pour les formulaires contenant des mots de passe'
                })
        
        # Test 3: Vérifier les uploads de fichiers
        has_file_upload = form.get('has_file_upload', False)
        if has_file_upload:
            # Vérifier si le type de fichier est restreint
            file_fields = [f for f in fields if f.get('type') == 'file']
            has_accept_restriction = any(
                'accept' in str(field).lower() or 
                field.get('accept') for field in file_fields
            )
            if not has_accept_restriction:
                security_issues['file_upload_unsafe'] = True
                vulnerabilities.append({
                    'type': 'Unrestricted File Upload',
                    'severity': 'High',
                    'description': f'Upload de fichier sans restriction de type: {action_url}',
                    'recommendation': 'Ajouter des restrictions sur les types de fichiers acceptés'
                })
        
        # Test 4: Test SQL Injection basique (si méthode POST)
        if method == 'POST' and fields:
            sql_payloads = ["' OR '1'='1", "1' OR '1'='1", "admin'--", "1' UNION SELECT NULL--"]
            test_field = None
            for field in fields:
                if field.get('type') not in ['hidden', 'submit', 'button']:
                    test_field = field.get('name')
                    break
            
            if test_field:
                try:
                    test_data = {test_field: sql_payloads[0]}
                    resp = requests.post(
                        action_url,
                        data=test_data,
                        timeout=5,
                        allow_redirects=False,
                        verify=False,
                        headers=self.headers
                    )
                    # Vérifier les erreurs SQL typiques dans la réponse
                    error_patterns = [
                        'sql syntax', 'mysql_fetch', 'ora-', 'postgresql',
                        'sqlite', 'sql error', 'warning.*mysql', 'unclosed quotation'
                    ]
                    response_text = (resp.text or '').lower()
                    if any(pattern in response_text for pattern in error_patterns):
                        security_issues['sql_injection'] = True
                        vulnerabilities.append({
                            'type': 'Potential SQL Injection',
                            'severity': 'High',
                            'description': f'Erreur SQL détectée lors du test sur: {action_url}',
                            'recommendation': 'Utiliser des requêtes préparées et valider les entrées'
                        })
                except:
                    pass  # Ignorer les erreurs de connexion
        
        # Test 5: Test XSS basique (si méthode GET ou POST)
        xss_payloads = ['<script>alert(1)</script>', '<img src=x onerror=alert(1)>', 'javascript:alert(1)']
        if fields:
            test_field = None
            for field in fields:
                if field.get('type') not in ['hidden', 'submit', 'button', 'password']:
                    test_field = field.get('name')
                    break
            
            if test_field:
                try:
                    test_data = {test_field: xss_payloads[0]}
                    if method == 'GET':
                        resp = requests.get(
                            action_url,
                            params=test_data,
                            timeout=5,
                            allow_redirects=False,
                            verify=False,
                            headers=self.headers
                        )
                    else:
                        resp = requests.post(
                            action_url,
                            data=test_data,
                            timeout=5,
                            allow_redirects=False,
                            verify=False,
                            headers=self.headers
                        )
                    # Vérifier si le payload est réfléchi dans la réponse
                    if xss_payloads[0] in resp.text:
                        security_issues['xss'] = True
                        vulnerabilities.append({
                            'type': 'Potential XSS Vulnerability',
                            'severity': 'Medium',
                            'description': f'Entrée utilisateur réfléchie sans encodage sur: {action_url}',
                            'recommendation': 'Encoder toutes les sorties utilisateur (HTML entities)'
                        })
                except:
                    pass  # Ignorer les erreurs de connexion
        
        return {
            'action': action_url,
            'method': method,
            'security_issues': security_issues,
            'vulnerabilities': vulnerabilities,
            'has_csrf': has_csrf,
            'has_password': has_password,
            'has_file_upload': has_file_upload
        }

    def scan_masscan(self, domain: str) -> Dict:
        """Scan rapide des ports avec masscan (ports communs)"""
        if not self.tools.get('masscan'):
            return {'error': 'masscan non disponible', 'open_ports': []}

        result = self._run_wsl_command([
            'masscan',
            domain,
            '--top-ports', '100',
            '--rate', '2000',
            '--wait', '0'
        ], timeout=45)

        open_ports = []
        if result.get('success'):
            for line in (result.get('stdout') or '').splitlines():
                if line.startswith('Discovered open port'):
                    try:
                        parts = line.split()
                        port_proto = parts[3]
                        host = parts[-1]
                        port = int(port_proto.split('/')[0])
                        proto = port_proto.split('/')[1]
                        open_ports.append({'port': port, 'protocol': proto, 'host': host})
                    except Exception:
                        continue

        return {
            'open_ports': open_ports,
            'scan_completed': result.get('success', False)
        }

    def scan_nmap_quick(self, url: str) -> Dict:
        """Scan Nmap rapide (top ports, services)"""
        if not self.tools.get('nmap'):
            return {'error': 'nmap non disponible', 'open_ports': []}

        parsed = urlparse(url)
        target = parsed.netloc or parsed.path.split('/')[0]

        result = self._run_wsl_command([
            'nmap',
            '-F',  # top 100 ports
            '-sV',  # version detection
            '-Pn',  # ne pas ping
            target
        ], timeout=90)

        open_ports = []
        services = []
        if result.get('success'):
            current_port = None
            for line in (result.get('stdout') or '').splitlines():
                if re.match(r'^\d+/(tcp|udp)', line):
                    parts = line.split()
                    port_proto = parts[0]
                    state = parts[1] if len(parts) > 1 else ''
                    service = parts[2] if len(parts) > 2 else ''
                    port = int(port_proto.split('/')[0])
                    proto = port_proto.split('/')[1]
                    if state == 'open':
                        open_ports.append({'port': port, 'protocol': proto})
                        services.append({'port': port, 'protocol': proto, 'service': service})
                    current_port = port
                elif current_port and '|' in line:
                    # Output script/extra info
                    services.append({'port': current_port, 'info': line.strip()})

        return {
            'open_ports': open_ports,
            'services': services,
            'scan_completed': result.get('success', False)
        }
    
    def scan_wapiti(self, url: str) -> Dict:
        """Scan de vulnérabilités avec Wapiti"""
        vulnerabilities = []
        
        if not self.tools['wapiti']:
            return {'error': 'wapiti non disponible', 'vulnerabilities': []}
        
        result = self._run_wsl_command([
            'wapiti',
            '-u', url,
            '-f', 'json',
            '--scope', 'folder'
        ], timeout=300)
        
        if result.get('success'):
            try:
                data = json.loads(result['stdout'])
                if 'vulnerabilities' in data:
                    for vuln in data['vulnerabilities']:
                        vulnerabilities.append({
                            'type': vuln.get('type', 'Unknown'),
                            'severity': vuln.get('severity', 'Medium'),
                            'description': vuln.get('description', ''),
                            'parameter': vuln.get('parameter', '')
                        })
            except:
                pass
        
        return {
            'vulnerabilities': vulnerabilities,
            'scan_completed': result.get('success', False)
        }
    
    def check_security_headers(self, url: str) -> Dict:
        """Vérifie les en-têtes de sécurité"""
        headers_analysis = {
            'missing': [],
            'present': [],
            'recommendations': []
        }
        
        try:
            response = requests.get(url, headers=self.headers, timeout=10, verify=False)
            headers = response.headers
            
            # Vérifier les en-têtes de sécurité importants
            security_headers = {
                'X-Frame-Options': 'Protection contre le clickjacking',
                'X-Content-Type-Options': 'Protection contre le MIME sniffing',
                'X-XSS-Protection': 'Protection XSS (obsolète mais encore utilisé)',
                'Strict-Transport-Security': 'HSTS - Force HTTPS',
                'Content-Security-Policy': 'CSP - Protection contre XSS',
                'Referrer-Policy': 'Contrôle des informations Referer',
                'Permissions-Policy': 'Contrôle des fonctionnalités du navigateur'
            }
            
            for header, description in security_headers.items():
                if header in headers:
                    headers_analysis['present'].append({
                        'header': header,
                        'value': headers[header],
                        'description': description
                    })
                else:
                    headers_analysis['missing'].append({
                        'header': header,
                        'description': description,
                        'severity': 'High' if header in ['Strict-Transport-Security', 'Content-Security-Policy'] else 'Medium'
                    })
            
            # Recommandations
            if not headers_analysis['present']:
                headers_analysis['recommendations'].append('Aucun en-tête de sécurité présent - Risque élevé')
            if 'Strict-Transport-Security' not in [h['header'] for h in headers_analysis['present']]:
                headers_analysis['recommendations'].append('HSTS manquant - Site vulnérable au downgrade HTTPS')
            if 'Content-Security-Policy' not in [h['header'] for h in headers_analysis['present']]:
                headers_analysis['recommendations'].append('CSP manquant - Protection XSS limitée')
        
        except Exception as e:
            headers_analysis['error'] = str(e)
        
        return headers_analysis
    
    def check_ssl_tls(self, domain: str) -> Dict:
        """Vérifie la configuration SSL/TLS"""
        ssl_analysis = {
            'vulnerabilities': [],
            'recommendations': [],
            'grade': 'A'
        }
        
        if not self.tools['sslscan']:
            return {'error': 'sslscan non disponible'}
        
        result = self._run_wsl_command(['sslscan', domain], timeout=30)
        
        if result.get('success'):
            output = result['stdout']
            
            # Détecter les vulnérabilités
            if 'SSLv2' in output and 'disabled' not in output.lower():
                ssl_analysis['vulnerabilities'].append({
                    'type': 'SSLv2 Enabled',
                    'severity': 'Critical',
                    'description': 'SSLv2 est obsolète et vulnérable'
                })
                ssl_analysis['grade'] = 'F'
            
            if 'SSLv3' in output and 'disabled' not in output.lower():
                ssl_analysis['vulnerabilities'].append({
                    'type': 'SSLv3 Enabled',
                    'severity': 'High',
                    'description': 'SSLv3 est vulnérable à POODLE'
                })
                if ssl_analysis['grade'] == 'A':
                    ssl_analysis['grade'] = 'C'
            
            if 'TLS 1.0' in output and 'disabled' not in output.lower():
                ssl_analysis['vulnerabilities'].append({
                    'type': 'TLS 1.0 Enabled',
                    'severity': 'Medium',
                    'description': 'TLS 1.0 est obsolète'
                })
                if ssl_analysis['grade'] in ['A', 'B']:
                    ssl_analysis['grade'] = 'C'
        
        return ssl_analysis
    
    def calculate_risk_score(self, vulnerabilities: List[Dict]) -> int:
        """Calcule un score de risque (0-100, 100 = très risqué)"""
        if not vulnerabilities:
            return 0
        
        score = 0
        severity_weights = {
            'Critical': 25,
            'High': 15,
            'Medium': 8,
            'Low': 3
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Medium')
            score += severity_weights.get(severity, 5)
        
        return min(100, score)
    
    def analyze_pentest(self, url: str, options: Dict = None) -> Dict:
        """
        Analyse de sécurité complète (Pentest)
        ⚠️ À utiliser uniquement avec autorisation écrite
        
        Args:
            url: URL à analyser
            options: Options de scan (sqlmap, wpscan, nikto, etc.)
        """
        if options is None:
            options = {
                'sqlmap': True,
                'wpscan': True,
                'nikto': True,
                'wapiti': False,  # Plus long
                'ffuf': True,
                'gobuster': False,  # Alternative à ffuf
                'dirsearch': False,  # Alternative à ffuf/gobuster
                'masscan': False,  # Rapide mais nécessite privileges réseau
                'nmap_quick': True,
                'security_headers': True,
                'ssl_tls': True
            }
        
        parsed = urlparse(url)
        domain = parsed.netloc or parsed.path.split('/')[0]
        domain = domain.replace('www.', '')
        
        results = {
            'url': url,
            'domain': domain,
            'vulnerabilities': [],
            'sql_injection': {},
            'xss_vulnerabilities': [],
            'csrf_vulnerabilities': [],
            'authentication_issues': [],
            'authorization_issues': [],
            'sensitive_data_exposure': [],
            'security_headers': {},
            'ssl_tls': {},
            'waf_detection': {},
            'cms_vulnerabilities': {},
            'api_security': {},
            'risk_score': 0,
            'summary': {}
        }
        
        # Scan SQL Injection
        if options.get('sqlmap', False):
            try:
                results['sql_injection'] = self.scan_sql_injection(url)
                results['vulnerabilities'].extend(results['sql_injection'].get('vulnerabilities', []))
            except Exception as e:
                results['sql_injection'] = {'error': str(e)}
        
        # Scan WordPress
        if options.get('wpscan', False) and ('wordpress' in url.lower() or 'wp-' in url.lower()):
            try:
                results['cms_vulnerabilities'] = self.scan_wordpress(url)
                results['vulnerabilities'].extend(results['cms_vulnerabilities'].get('vulnerabilities', []))
            except Exception as e:
                results['cms_vulnerabilities'] = {'error': str(e)}
        
        # Scan Nikto
        if options.get('nikto', False):
            try:
                nikto_results = self.scan_nikto(url)
                results['vulnerabilities'].extend(nikto_results.get('vulnerabilities', []))
            except Exception as e:
                results['nikto_error'] = str(e)

        # Bruteforce répertoires (ffuf)
        if options.get('ffuf', False):
            try:
                ffuf_results = self.scan_ffuf_directories(url)
                results['vulnerabilities'].extend(ffuf_results.get('vulnerabilities', []))
                results['ffuf'] = ffuf_results
            except Exception as e:
                results['ffuf_error'] = str(e)
        
        # Bruteforce répertoires (gobuster) - alternative à ffuf
        if options.get('gobuster', False):
            try:
                gobuster_results = self.scan_gobuster_directories(url)
                results['vulnerabilities'].extend(gobuster_results.get('vulnerabilities', []))
                results['gobuster'] = gobuster_results
            except Exception as e:
                results['gobuster_error'] = str(e)
        
        # Bruteforce répertoires (dirsearch) - alternative à ffuf/gobuster
        if options.get('dirsearch', False):
            try:
                dirsearch_results = self.scan_dirsearch_directories(url)
                results['vulnerabilities'].extend(dirsearch_results.get('vulnerabilities', []))
                results['dirsearch'] = dirsearch_results
            except Exception as e:
                results['dirsearch_error'] = str(e)
        
        # Scan Wapiti (optionnel, plus long)
        if options.get('wapiti', False):
            try:
                wapiti_results = self.scan_wapiti(url)
                results['vulnerabilities'].extend(wapiti_results.get('vulnerabilities', []))
            except Exception as e:
                results['wapiti_error'] = str(e)
        
        # Vérification des en-têtes de sécurité
        if options.get('security_headers', True):
            try:
                results['security_headers'] = self.check_security_headers(url)
            except Exception as e:
                results['security_headers'] = {'error': str(e)}
        
        # Vérification SSL/TLS
        if options.get('ssl_tls', True):
            try:
                results['ssl_tls'] = self.check_ssl_tls(domain)
                results['vulnerabilities'].extend(results['ssl_tls'].get('vulnerabilities', []))
            except Exception as e:
                results['ssl_tls'] = {'error': str(e)}

        # Scan Nmap rapide
        if options.get('nmap_quick', False):
            try:
                nmap_results = self.scan_nmap_quick(url)
                results['nmap'] = nmap_results
                # Ajouter les services trouvés dans les vulnérabilités low
                for svc in nmap_results.get('services', []):
                    results['vulnerabilities'].append({
                        'type': 'Service Exposure',
                        'severity': 'Low',
                        'description': f"Service détecté: port {svc.get('port')} {svc.get('protocol')} {svc.get('service', '')}".strip()
                    })
            except Exception as e:
                results['nmap_error'] = str(e)

        # Scan masscan rapide (optionnel)
        if options.get('masscan', False):
            try:
                masscan_results = self.scan_masscan(domain)
                results['masscan'] = masscan_results
                for port in masscan_results.get('open_ports', []):
                    results['vulnerabilities'].append({
                        'type': 'Open Port',
                        'severity': 'Low',
                        'description': f"Port ouvert: {port.get('port')}/{port.get('protocol')}"
                    })
            except Exception as e:
                results['masscan_error'] = str(e)
        
        # Calcul du score de risque
        results['risk_score'] = self.calculate_risk_score(results['vulnerabilities'])
        
        # Résumé
        results['summary'] = {
            'total_vulnerabilities': len(results['vulnerabilities']),
            'critical_count': len([v for v in results['vulnerabilities'] if v.get('severity') == 'Critical']),
            'high_count': len([v for v in results['vulnerabilities'] if v.get('severity') == 'High']),
            'medium_count': len([v for v in results['vulnerabilities'] if v.get('severity') == 'Medium']),
            'low_count': len([v for v in results['vulnerabilities'] if v.get('severity') == 'Low']),
            'risk_level': 'Critical' if results['risk_score'] >= 70 else 'High' if results['risk_score'] >= 40 else 'Medium' if results['risk_score'] >= 20 else 'Low'
        }
        
        return results

